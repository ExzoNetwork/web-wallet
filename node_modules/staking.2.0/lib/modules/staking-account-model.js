"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StakingAccountModel = void 0;

var _bn = _interopRequireDefault(require("bn.js"));

var _mobx = require("mobx");

var _rewardModel = require("./reward-model");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//const solanaWeb3 = require('./index.cjs.js');
var solanaWeb3 = require('@velas/web3');

var StakingAccountModel = /*#__PURE__*/function () {
  function StakingAccountModel(account, connection, network) {
    _classCallCheck(this, StakingAccountModel);

    _defineProperty(this, "account", null);

    _defineProperty(this, "myStake", null);

    _defineProperty(this, "network", null);

    _defineProperty(this, "isActivated", null);

    _defineProperty(this, "connection", null);

    _defineProperty(this, "rewards", null);

    _defineProperty(this, "rewardsStatus", 'NotLoaded');

    _defineProperty(this, "isActivationRequested", false);

    _defineProperty(this, "_activeStake", null);

    _defineProperty(this, "_inactiveStake", null);

    _defineProperty(this, "_state", null);

    _defineProperty(this, "latestReward", undefined);

    this.connection = connection;
    this.network = network;
    this.account = account;
    var lamports = account.lamports,
        activationEpoch = account.activationEpoch,
        deactivationEpoch = account.deactivationEpoch,
        rentExemptReserve = account.rentExemptReserve,
        withdrawer = account.withdrawer,
        stake = account.stake,
        pubkey = account.pubkey,
        staker = account.staker,
        voter = account.voter;

    if (stake) {
      this.isActivated = deactivationEpoch === '18446744073709551615';
    } else {
      this.isActivated = false;
    }

    this.myStake = new _bn.default(lamports + '', 10);
    this.loadRewards();
    (0, _mobx.decorate)(this, {
      rewardsStatus: _mobx.observable,
      rewards: _mobx.observable,
      _activeStake: _mobx.observable,
      _inactiveStake: _mobx.observable,
      _state: _mobx.observable,
      latestReward: _mobx.observable,
      activeStakeIsLoading: _mobx.observable
    });
  } // fetchEpochRewards = (address, activationEpoch, cb)->
  //     return cb null, [] if (not store.staking.chosenAccount.validator? or store.staking.chosenAccount.validator.toString!.length is 0)
  //     err, epochSchedule <- as-callback(web3t.velas.NativeStaking.getEpochSchedule!)
  //     console.error err if err?
  //     {firstNormalEpoch, firstNormalSlot, leaderScheduleSlotOffset, slotsPerEpoch, warmup} = epochSchedule
  //     err, slot <- as-callback(web3t.velas.NativeStaking.getSlot!)
  //     console.error err if err?
  //     err, firstAvailableBlock <- as-callback(web3t.velas.NativeStaking.getFirstAvailableBlock!)
  //     console.error err if err?
  //     err, epochInfo <- as-callback web3t.velas.NativeStaking.getCurrentEpochInfo()
  //     console.error err if err?
  //     return cb null if err?
  //     { epoch } = epochInfo
  //     # make loop here!
  //     err, rewards <- query-rewards-loop(address, activationEpoch, firstNormalSlot, slotsPerEpoch, firstAvailableBlock, firstNormalEpoch, epoch)
  //     cb null, rewards


  _createClass(StakingAccountModel, [{
    key: "address",
    get: function get() {
      return this.account.pubkey;
    }
  }, {
    key: "publicKey",
    get: function get() {
      return this.account.pubkey;
    }
  }, {
    key: "validatorAddress",
    get: function get() {
      return this.account.voter;
    }
  }, {
    key: "activeStake",
    get: function get() {
      if (!this._activeStake) this.requestActivation();
      return this._activeStake;
    }
  }, {
    key: "inactiveStake",
    get: function get() {
      if (!this._inactiveStake) this.requestActivation();
      return this._inactiveStake;
    }
  }, {
    key: "state",
    get: function get() {
      if (!this._state) this.requestActivation();
      return this._state;
    }
  }, {
    key: "isRewardsLoading",
    get: function get() {
      switch (this.rewardsStatus) {
        case 'NotLoaded':
          return true;

        case '1Loaded':
          return false;

        case 'LoadingMore':
          return true;

        case 'LoadedAll':
          return false;
      }

      console.error('Invalid rewardsStatus', this.rewardsStatus);
      return false;
    }
  }, {
    key: "activeStakeIsLoading",
    get: function get() {
      return this.isActivationRequested;
    }
  }, {
    key: "requestActivation",
    value: function () {
      var _requestActivation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _this = this;

        var start, activationRes, active, inactive, state, end;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.isActivationRequested) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                //console.log("[requestActivation] start");
                start = Date.now();
                this.isActivationRequested = true;
                _context2.next = 6;
                return (0, _utils.cachedCallWithRetries)(this.network, ['getStakeActivation', this.connection, new solanaWeb3.PublicKey(this.account.pubkey)], /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.prev = 0;
                          _context.next = 3;
                          return _this.connection.getStakeActivation(new solanaWeb3.PublicKey(_this.account.pubkey));

                        case 3:
                          return _context.abrupt("return", _context.sent);

                        case 6:
                          _context.prev = 6;
                          _context.t0 = _context["catch"](0);

                          if (!_context.t0.message || !_context.t0.message.includes('failed to get Stake Activation')) {// this is quite unsafe to throw errors in getters
                            //throw e;
                          }

                          console.warn(_context.t0);
                          return _context.abrupt("return", null);

                        case 11:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, null, [[0, 6]]);
                })));

              case 6:
                activationRes = _context2.sent;

                if (activationRes) {
                  _context2.next = 13;
                  break;
                }

                console.warn('Invalid activation response');
                this._activeStake = new _bn.default(0);
                this._inactiveStake = new _bn.default(0);
                this._state = 'inactive';
                return _context2.abrupt("return");

              case 13:
                active = activationRes.active, inactive = activationRes.inactive, state = activationRes.state;
                this._activeStake = new _bn.default(active + '', 10);
                this._inactiveStake = new _bn.default(inactive + '', 10);
                this._state = state;
                end = Date.now(); //console.log("[requestActivation] end", (end - start)/1000 , ' seconds');

              case 18:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function requestActivation() {
        return _requestActivation.apply(this, arguments);
      }

      return requestActivation;
    }()
  }, {
    key: "loadMoreRewards",
    value: function () {
      var _loadMoreRewards = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var _this2 = this;

        var _loop, i, _ret;

        return regeneratorRuntime.wrap(function _callee3$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.t0 = this.rewardsStatus;
                _context4.next = _context4.t0 === 'NotLoaded' ? 3 : _context4.t0 === '1Loaded' ? 8 : _context4.t0 === 'LoadingMore' ? 9 : _context4.t0 === 'LoadedAll' ? 10 : 11;
                break;

              case 3:
                _context4.next = 5;
                return (0, _mobx.when)(function () {
                  return _this2.rewardsStatus === '1Loaded';
                });

              case 5:
                if (!(this.rewardsStatus !== '1Loaded')) {
                  _context4.next = 7;
                  break;
                }

                return _context4.abrupt("return");

              case 7:
                return _context4.abrupt("break", 11);

              case 8:
                return _context4.abrupt("break", 11);

              case 9:
                return _context4.abrupt("return");

              case 10:
                return _context4.abrupt("return");

              case 11:
                this.rewards = [];
                this.rewardsStatus = 'LoadingMore';
                _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop(i) {
                  var _yield$_this2$getEpoc, firstNormalEpoch, firstNormalSlot, leaderScheduleSlotOffset, slotsPerEpoch, warmup, epoch, firstSlotInEpoch, blockNumberResult, blockResult, address, rewards;

                  return regeneratorRuntime.wrap(function _loop$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 2;
                          return _this2.getEpochSchedule();

                        case 2:
                          _yield$_this2$getEpoc = _context3.sent;
                          firstNormalEpoch = _yield$_this2$getEpoc.firstNormalEpoch;
                          firstNormalSlot = _yield$_this2$getEpoc.firstNormalSlot;
                          leaderScheduleSlotOffset = _yield$_this2$getEpoc.leaderScheduleSlotOffset;
                          slotsPerEpoch = _yield$_this2$getEpoc.slotsPerEpoch;
                          warmup = _yield$_this2$getEpoc.warmup;
                          _context3.next = 10;
                          return _this2.getLastEpoch();

                        case 10:
                          epoch = _context3.sent;
                          firstSlotInEpoch = (epoch - i - firstNormalEpoch) * slotsPerEpoch + firstNormalSlot;
                          _context3.next = 14;
                          return _this2.getConfirmedBlocksWithLimit(firstSlotInEpoch);

                        case 14:
                          blockNumberResult = _context3.sent;
                          _context3.next = 17;
                          return _this2.getConfirmedBlock(blockNumberResult.result[0]);

                        case 17:
                          blockResult = _context3.sent;
                          address = _this2.address;
                          rewards = blockResult.rewards.filter(function (r) {
                            return r.pubkey === address;
                          }).map(function (reward) {
                            return new _rewardModel.RewardModel(reward, epoch - i - 1, _this2.connection, _this2.network);
                          });

                          if (!(rewards.length === 0)) {
                            _context3.next = 22;
                            break;
                          }

                          return _context3.abrupt("return", "break");

                        case 22:
                          _this2.rewards = _this2.rewards.concat(rewards); // for (let reward of rewards) {
                          //   this.rewards.push(reward);
                          // }

                        case 23:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _loop);
                });
                i = 0;

              case 15:
                if (!(i < 10)) {
                  _context4.next = 23;
                  break;
                }

                return _context4.delegateYield(_loop(i), "t1", 17);

              case 17:
                _ret = _context4.t1;

                if (!(_ret === "break")) {
                  _context4.next = 20;
                  break;
                }

                return _context4.abrupt("break", 23);

              case 20:
                i++;
                _context4.next = 15;
                break;

              case 23:
                this.rewardsStatus = 'LoadedAll';

              case 24:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee3, this);
      }));

      function loadMoreRewards() {
        return _loadMoreRewards.apply(this, arguments);
      }

      return loadMoreRewards;
    }()
  }, {
    key: "getEpochSchedule",
    value: function () {
      var _getEpochSchedule = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _this3 = this;

        return regeneratorRuntime.wrap(function _callee4$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return (0, _utils.cachedCallWithRetries)(this.network, ['getEpochSchedule', this.connection], function () {
                  return _this3.connection.getEpochSchedule();
                });

              case 2:
                return _context5.abrupt("return", _context5.sent);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee4, this);
      }));

      function getEpochSchedule() {
        return _getEpochSchedule.apply(this, arguments);
      }

      return getEpochSchedule;
    }()
  }, {
    key: "getEpochInfo",
    value: function () {
      var _getEpochInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var _this4 = this;

        return regeneratorRuntime.wrap(function _callee5$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return (0, _utils.cachedCallWithRetries)(this.network, ['getEpochInfo', this.connection], function () {
                  return _this4.connection.getEpochInfo();
                });

              case 2:
                return _context6.abrupt("return", _context6.sent);

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee5, this);
      }));

      function getEpochInfo() {
        return _getEpochInfo.apply(this, arguments);
      }

      return getEpochInfo;
    }()
  }, {
    key: "getConfirmedBlocksWithLimit",
    value: function () {
      var _getConfirmedBlocksWithLimit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(firstSlotInEpoch) {
        var _this5 = this;

        return regeneratorRuntime.wrap(function _callee6$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return (0, _utils.cachedCallWithRetries)(this.network, ['getConfirmedBlocksWithLimit', this.connection, firstSlotInEpoch, 1], function () {
                  return _this5.connection.getConfirmedBlocksWithLimit(firstSlotInEpoch, 1);
                });

              case 2:
                return _context7.abrupt("return", _context7.sent);

              case 3:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee6, this);
      }));

      function getConfirmedBlocksWithLimit(_x) {
        return _getConfirmedBlocksWithLimit.apply(this, arguments);
      }

      return getConfirmedBlocksWithLimit;
    }()
  }, {
    key: "getConfirmedBlock",
    value: function () {
      var _getConfirmedBlock = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(blockNumber) {
        var _this6 = this;

        return regeneratorRuntime.wrap(function _callee7$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return (0, _utils.cachedCallWithRetries)(this.network, ['getConfirmedBlock', this.connection, blockNumber], function () {
                  return _this6.connection.getConfirmedBlock(blockNumber, 'confirmed');
                });

              case 2:
                return _context8.abrupt("return", _context8.sent);

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee7, this);
      }));

      function getConfirmedBlock(_x2) {
        return _getConfirmedBlock.apply(this, arguments);
      }

      return getConfirmedBlock;
    }()
  }, {
    key: "loadRewards",
    value: function () {
      var _loadRewards = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var _this7 = this;

        var _yield$this$getEpochS, firstNormalEpoch, firstNormalSlot, leaderScheduleSlotOffset, slotsPerEpoch, warmup, _yield$this$getEpochI, epoch, firstSlotInEpoch, blockNumberResult, blockResult, address;

        return regeneratorRuntime.wrap(function _callee8$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.prev = 0;
                _context9.next = 3;
                return this.getEpochSchedule();

              case 3:
                _yield$this$getEpochS = _context9.sent;
                firstNormalEpoch = _yield$this$getEpochS.firstNormalEpoch;
                firstNormalSlot = _yield$this$getEpochS.firstNormalSlot;
                leaderScheduleSlotOffset = _yield$this$getEpochS.leaderScheduleSlotOffset;
                slotsPerEpoch = _yield$this$getEpochS.slotsPerEpoch;
                warmup = _yield$this$getEpochS.warmup;
                _context9.next = 11;
                return this.getEpochInfo();

              case 11:
                _yield$this$getEpochI = _context9.sent;
                epoch = _yield$this$getEpochI.epoch;
                firstSlotInEpoch = (epoch - firstNormalEpoch) * slotsPerEpoch + firstNormalSlot;
                _context9.next = 16;
                return this.getConfirmedBlocksWithLimit(firstSlotInEpoch);

              case 16:
                blockNumberResult = _context9.sent;
                _context9.next = 19;
                return this.getConfirmedBlock(blockNumberResult.result[0]);

              case 19:
                blockResult = _context9.sent;
                address = this.address;
                this.latestReward = blockResult.rewards.filter(function (r) {
                  return r.pubkey === address;
                }).slice(0, 1).map(function (reward) {
                  return new _rewardModel.RewardModel(reward, epoch - 1, _this7.connection, _this7.network);
                })[0] || null;
                this.rewardsStatus = '1Loaded';
                _context9.next = 28;
                break;

              case 25:
                _context9.prev = 25;
                _context9.t0 = _context9["catch"](0);
                console.error(_context9.t0);

              case 28:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee8, this, [[0, 25]]);
      }));

      function loadRewards() {
        return _loadRewards.apply(this, arguments);
      }

      return loadRewards;
    }()
  }, {
    key: "getLastEpoch",
    value: function () {
      var _getLastEpoch = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var info, epoch, deactivationEpoch;
        return regeneratorRuntime.wrap(function _callee9$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getEpochInfo();

              case 2:
                info = _context10.sent;
                epoch = info.epoch;

                if (!(this.isActivated || !this.account || !this.account.stake)) {
                  _context10.next = 6;
                  break;
                }

                return _context10.abrupt("return", epoch);

              case 6:
                deactivationEpoch = this.account.deactivationEpoch;
                return _context10.abrupt("return", Math.min(parseInt(deactivationEpoch) + 1, epoch));

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee9, this);
      }));

      function getLastEpoch() {
        return _getLastEpoch.apply(this, arguments);
      }

      return getLastEpoch;
    }()
  }]);

  return StakingAccountModel;
}();

exports.StakingAccountModel = StakingAccountModel;