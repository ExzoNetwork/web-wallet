"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StakingStore = void 0;

var _mobx = require("mobx");

var _bn = _interopRequireDefault(require("bn.js"));

var _bs = _interopRequireDefault(require("bs58"));

var _validatorModel = require("./validator-model.js");

var _validatorModelBacked = require("./validator-model-backed.js");

var _stakingAccountModel = require("./staking-account-model.js");

var _crossFetch = _interopRequireDefault(require("cross-fetch"));

var _buffer = require("buffer");

var _web = require("@velas/web3");

var _utils = require("./utils");

var _isomorphicWebcrypto = _interopRequireDefault(require("isomorphic-webcrypto"));

var _web2 = _interopRequireDefault(require("web3"));

var _rewardsStore = require("./rewards-store");

var _EvmToNativeBridge = _interopRequireDefault(require("./EvmToNativeBridge.js"));

var ethereum = _interopRequireWildcard(require("ethereumjs-tx"));

var _ethereumjsCommon = _interopRequireDefault(require("ethereumjs-common"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

// import Store from "../wallet/data-scheme.js";
var SOL = new _bn.default('1000000000', 10);
var PRESERVE_BALANCE = new _bn.default('1000000000', 10); // const  = mobx;

function tryFixCrypto() {
  return _tryFixCrypto.apply(this, arguments);
}

function _tryFixCrypto() {
  _tryFixCrypto = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
    var originalDigest;
    return regeneratorRuntime.wrap(function _callee20$(_context20) {
      while (1) {
        switch (_context20.prev = _context20.next) {
          case 0:
            _context20.prev = 0;

            if (!(global.globalThis && global.globalThis.crypto === _isomorphicWebcrypto.default)) {
              _context20.next = 3;
              break;
            }

            return _context20.abrupt("return");

          case 3:
            _context20.next = 5;
            return _isomorphicWebcrypto.default.ensureSecure();

          case 5:
            if (!(global.globalThis && global.globalThis.crypto === _isomorphicWebcrypto.default)) {
              _context20.next = 7;
              break;
            }

            return _context20.abrupt("return");

          case 7:
            originalDigest = _isomorphicWebcrypto.default.subtle.digest.bind(_isomorphicWebcrypto.default.subtle);

            _isomorphicWebcrypto.default.subtle.digest = function (algorithm, buffer) {
              if (typeof algorithm === 'string') {
                algorithm = {
                  name: algorithm
                };
              }

              return originalDigest(algorithm, buffer);
            };

            if (!global.globalThis) {
              global.globalThis = {};
            }

            global.globalThis.crypto = _isomorphicWebcrypto.default;
            _context20.next = 16;
            break;

          case 13:
            _context20.prev = 13;
            _context20.t0 = _context20["catch"](0);
            console.log('Cannot fix crypto', _context20.t0.message);

          case 16:
          case "end":
            return _context20.stop();
        }
      }
    }, _callee20, null, [[0, 13]]);
  }));
  return _tryFixCrypto.apply(this, arguments);
}

tryFixCrypto();
var MIN_VALIDATOR_STAKE = new _bn.default('1000000000000000', 10);

var StakingStore = /*#__PURE__*/function () {
  function StakingStore(config) {
    var _this = this;

    _classCallCheck(this, StakingStore);

    _defineProperty(this, "validators", null);

    _defineProperty(this, "accounts", null);

    _defineProperty(this, "vlxEvmBalance", null);

    _defineProperty(this, "vlxNativeBalance", null);

    _defineProperty(this, "validatorDetailsLoading", void 0);

    _defineProperty(this, "isRefreshing", false);

    _defineProperty(this, "fetchAccountsFromBackend", false);

    _defineProperty(this, "rent", null);

    _defineProperty(this, "seedUsed", Object.create(null));

    _defineProperty(this, "connection", null);

    _defineProperty(this, "openedValidatorAddress", null);

    _defineProperty(this, "evmAddress", null);

    _defineProperty(this, "epochInfo", null);

    _defineProperty(this, "network", null);

    _defineProperty(this, "evmAPI", '');

    _defineProperty(this, "publicKey", null);

    _defineProperty(this, "_currentSort", null);

    _defineProperty(this, "getValidatorsError", null);

    _defineProperty(this, "isLoading", false);

    _defineProperty(this, "loadEpochInfo", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var info;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this.getEpochInfo();

            case 2:
              info = _context.sent;
              return _context.abrupt("return", info);

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));

    _defineProperty(this, "getAccounts", /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(accounts) {
        var res, nativeAccounts;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (accounts) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return", []);

              case 2:
                res = [];
                nativeAccounts = [];

                if (!_this.fetchAccountsFromBackend) {
                  _context2.next = 11;
                  break;
                }

                _context2.next = 7;
                return accounts.json();

              case 7:
                nativeAccounts = _context2.sent;
                res = nativeAccounts ? nativeAccounts.stakingAccounts : [];
                _context2.next = 13;
                break;

              case 11:
                nativeAccounts = accounts;
                res = (nativeAccounts || []).map(function (item) {
                  var acc = item.account;
                  var pubkey = item.pubkey.toString();
                  var _acc$data$parsed$info = acc.data.parsed.info,
                      meta = _acc$data$parsed$info.meta,
                      stake = _acc$data$parsed$info.stake;
                  return {
                    activationEpoch: stake ? stake.delegation.activationEpoch : null,
                    creditsObserved: stake ? stake.creditsObserved : null,
                    custodian: meta.lockup.custodian,
                    deactivationEpoch: stake ? stake.delegation.deactivationEpoch : 0,
                    epoch: 0,
                    lamports: acc.lamports,
                    lockupUnixTimestamp: meta.lockup.unixTimestamp,
                    pubkey: pubkey,
                    rentExemptReserve: meta.rentExemptReserve,
                    staker: meta.authorized.staker,
                    voter: stake ? stake.delegation.voter : null,
                    withdrawer: meta.authorized.withdrawer
                  };
                });

              case 13:
                return _context2.abrupt("return", res);

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }());

    _defineProperty(this, "startRefresh", function () {
      _this.validators = null;
      _this.accounts = null;
      _this.rent = null;
      _this.vlxNativeBalance = null;
      _this.vlxEvmBalance = null;
      _this.epochInfo = null;
    });

    _defineProperty(this, "endRefresh", function (balanceRes, balanceEvmJson, rent, validators, stakingAccounts, epochInfo) {
      _this.vlxNativeBalance = balanceRes ? new _bn.default(balanceRes + '', 10) : new _bn.default('0');
      _this.vlxEvmBalance = balanceEvmJson ? new _bn.default(balanceEvmJson.result.substr(2), 16).div(new _bn.default(1e9)) : new _bn.default('0');
      _this.rent = rent ? new _bn.default(rent) : new _bn.default('0');
      _this.validators = validators || [];
      _this.accounts = stakingAccounts || [];
      _this.epochInfo = epochInfo;
    });

    _defineProperty(this, "getStakedValidators", function () {
      if (!_this.validators) {
        return [];
      }

      return _this.validators.filter(function (validator) {
        return !validator.myStake.isZero();
      });
    });

    _defineProperty(this, "getNotStakedValidators", function () {
      if (!_this.validators) {
        return [];
      }

      return _this.validators.filter(function (v) {
        var myStake = v.myStake;
        return myStake.isZero();
      });
    });

    _defineProperty(this, "getAllValidators", function () {
      if (!_this.validators) {
        return null;
      }

      return _this.validators.filter(function (validator) {
        return validator.myStake;
      });
    });

    _defineProperty(this, "getValidatorDetails", function () {
      var validatorAddress = _this.openedValidatorAddress;

      if (typeof validatorAddress !== 'string') {
        throw new Error('openedValidatorAddress need to be set');
      }

      if (!_this.validators) return null;

      var validator = _this.validators.find(function (_ref3) {
        var address = _ref3.address;
        return address === validatorAddress;
      });

      if (!validator) {
        return null; //throw new Error('Validator not found');
      }

      return {
        address: validatorAddress,
        identity: validator.identity,
        dominance: _this.getDominance(validator),
        quality: _this.getQuality(validator),
        annualPercentageRate: _this.getAnnualRate(validator),
        apr: validator.apr,
        commission: validator.commission,
        status: validator.status,
        myStake: validator.myStake,
        activeStake: validator.activeStake,
        stakeDataIsLoaded: !validator.myStake || validator.myStake.isZero() || validator.totalActiveStake !== null && validator.totalInactiveStake !== null,
        name: validator.name,
        available_balance: _this.getBalance(),
        myActiveStake: validator.totalActiveStake && validator.totalInactiveStake && (!validator.totalActiveStake.isZero() || !validator.totalInactiveStake.isZero() || null) && validator.totalActiveStake.mul(new _bn.default(100)).div(validator.totalActiveStake.add(validator.totalInactiveStake)).toString(10),
        totalWithdrawRequested: validator.totalWithdrawRequested,
        availableWithdrawRequested: validator.availableWithdrawRequested,
        totalActiveStake: validator.totalActiveStake,
        totalActivatingStake: validator.totalActivatingStake,
        totalDeactivatingStake: validator.totalDeactivatingStake,
        totalInactiveStake: validator.totalInactiveStake,
        totalAvailableForWithdrawRequestStake: validator.totalAvailableForWithdrawRequestStake
      };
    });

    _defineProperty(this, "getRewards", function () {
      var validatorAddress = _this.openedValidatorAddress;

      if (typeof validatorAddress !== 'string') {
        throw new Error('openedValidatorAddress need to be set');
      }

      var validator = _this.validators.find(function (_ref4) {
        var address = _ref4.address;
        return address === validatorAddress;
      });

      if (!validator) {
        throw new Error('Validator not found');
      }

      return {
        rewards: validator.rewards || [],
        isLoading: validator.isRewardsLoading
      };
    });

    _defineProperty(this, "loadMoreRewards", function () {
      var validatorAddress = _this.openedValidatorAddress;

      if (typeof validatorAddress !== 'string' || !_this.validators) {
        return;
      }

      var validator = _this.validators.find(function (_ref5) {
        var address = _ref5.address;
        return address === validatorAddress;
      });

      if (!validator) {
        return;
      }

      validator.loadMoreRewards();
    });

    var API_HOST = config.API_HOST,
        evmAPI = config.evmAPI,
        validatorsBackend = config.validatorsBackend,
        publicKey = config.publicKey,
        evmAddress = config.evmAddress,
        evmPrivateKey = config.evmPrivateKey,
        network = config.network,
        nativePrivateKey = config.nativePrivateKey,
        nativeApi = config.nativeApi,
        fetchAccountsFromBackend = config.fetchAccountsFromBackend;
    this.secretKey = _bs.default.decode(nativePrivateKey); //const publicKeyBuffer = {"data": [175, 102, 145, 237, 171, 197, 51, 43, 232, 19, 173, 90, 60, 193, 229, 148, 133, 170, 191, 102, 23, 245, 139, 32, 56, 241, 184, 208, 245, 20, 86, 221], "type": "Buffer"}

    this.publicKey58 = publicKey;
    this.publicKey = new _web.PublicKey(publicKey);
    this.connection = new _web.Connection(nativeApi, 'confirmed');
    this.evmAddress = evmAddress;
    this.evmPrivateKey = evmPrivateKey;
    this.network = network;
    this.evmAPI = evmAPI;
    this.validatorsBackend = validatorsBackend;
    this.validatorDetailsLoading = false;
    this.fetchAccountsFromBackend = true;
    this.getValidatorsError = null;
    this.isLoading = false;
    this.web3 = new _web2.default(new _web2.default.providers.HttpProvider(evmAPI));

    _rewardsStore.rewardsStore.setConnection(this.connection, network);

    (0, _mobx.decorate)(this, {
      connection: _mobx.observable,
      validators: _mobx.observable,
      vlxEvmBalance: _mobx.observable,
      vlxNativeBalance: _mobx.observable,
      isRefreshing: _mobx.observable,
      validatorDetailsLoading: _mobx.observable,
      accounts: _mobx.observable,
      openedValidatorAddress: _mobx.observable,
      epochInfo: _mobx.observable,
      _currentSort: _mobx.observable,
      getValidatorsError: _mobx.observable,
      isLoading: _mobx.observable
    }); // rewardsStore.loadLatestRewards(() => {

    this.startRefresh = (0, _mobx.action)(this.startRefresh);
    this.endRefresh = (0, _mobx.action)(this.endRefresh);
    this.init(); // });
  }

  _createClass(StakingStore, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                console.log("init");
                _context3.next = 3;
                return tryFixCrypto();

              case 3:
                _context3.next = 5;
                return this.reloadWithRetry();

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "reloadWithRetry",
    value: function () {
      var _reloadWithRetry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var _this2 = this;

        var validators;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this.isRefreshing) {
                  _context5.next = 4;
                  break;
                }

                _context5.next = 3;
                return (0, _mobx.when)(function () {
                  return !_this2.isRefreshing;
                });

              case 3:
                return _context5.abrupt("return", _context5.sent);

              case 4:
                this.isLoading = true;
                this.isRefreshing = true;
                (0, _utils.invalidateCache)();
                _context5.prev = 7;
                _context5.next = 10;
                return (0, _utils.callWithRetries)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
                  return regeneratorRuntime.wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          _context4.next = 2;
                          return _this2.reloadFromBackend();

                        case 2:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                })), null, 5);

              case 10:
                _context5.next = 16;
                break;

              case 12:
                _context5.prev = 12;
                _context5.t0 = _context5["catch"](7);
                console.error(_context5.t0); //Cannot load from backend. Use slower method.

                this.reload();

              case 16:
                validators = this.validators || [];
                if (validators.replace) this.sort === 'total_staked' ? validators.replace(validators.slice().sort(function (v1, v2) {
                  return v2.activeStake - v1.activeStake;
                })) : validators.replace(validators.slice().sort(function (v1, v2) {
                  return v2.apr - v1.apr - (v1.activeStake && v1.activeStake.gte(MIN_VALIDATOR_STAKE) ? 1000 : 0) + (v2.activeStake && v2.activeStake.gte(MIN_VALIDATOR_STAKE) ? 1000 : 0) - (v1.status === 'active' ? 2000 : 0) + (v2.status === 'active' ? 2000 : 0);
                })); //}

                this.isRefreshing = false;
                this.isLoading = false;

              case 20:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[7, 12]]);
      }));

      function reloadWithRetry() {
        return _reloadWithRetry.apply(this, arguments);
      }

      return reloadWithRetry;
    }()
  }, {
    key: "sortActiveStake",
    value: function () {
      var _sortActiveStake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var _this3 = this;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!(this.validators.length > 0)) {
                  _context6.next = 4;
                  break;
                }

                _context6.next = 3;
                return (0, _mobx.when)(function () {
                  return _this3.validators && _this3.validators.length && _this3.validators[0].activeStake !== null;
                });

              case 3:
                this.validators.replace(this.validators.slice().sort(function (v1, v2) {
                  return v2.activeStake - v1.activeStake;
                }));

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function sortActiveStake() {
        return _sortActiveStake.apply(this, arguments);
      }

      return sortActiveStake;
    }()
  }, {
    key: "sortApr",
    value: function () {
      var _sortApr = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var _this4 = this;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(this.validators.length > 0)) {
                  _context7.next = 4;
                  break;
                }

                _context7.next = 3;
                return (0, _mobx.when)(function () {
                  return _this4.validators && _this4.validators.length && _this4.validators[0].apr !== null;
                });

              case 3:
                this.validators.replace(this.validators.slice().sort(function (v1, v2) {
                  return v2.apr - v1.apr;
                }));

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function sortApr() {
        return _sortApr.apply(this, arguments);
      }

      return sortApr;
    }()
  }, {
    key: "getEpochInfo",
    value: function () {
      var _getEpochInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var _this5 = this;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return (0, _utils.cachedCallWithRetries)(this.network, ['getEpochInfo', this.connection], function () {
                  return _this5.connection.getEpochInfo();
                });

              case 2:
                return _context8.abrupt("return", _context8.sent);

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getEpochInfo() {
        return _getEpochInfo.apply(this, arguments);
      }

      return getEpochInfo;
    }() // async getConfirmedBlock(blockNumber) {
    //   return await cachedCallWithRetries(
    //     this.network,
    //     ['getConfirmedBlock', this.connection, blockNumber],
    //     () => this.connection.getConfirmedBlock(blockNumber, 1),
    //   );
    // }

  }, {
    key: "reloadFromBackend",
    value: function () {
      var _reloadFromBackend = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var _this6 = this;

        var filter, _result, epochInfo, balanceRes, balanceEvmRes, validatorsFromBackendResult, nativeAccountsFromBackendResult, validatorsFromBackend, result, balanceEvmJson, nativeAccounts, filteredAccounts, stakingAccounts, tmp, validators, validatorsMap, i, account, validator, rent;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                this.startRefresh();
                filter = {
                  memcmp: {
                    offset: 0xc,
                    bytes: this.publicKey58
                  }
                };
                _context9.next = 4;
                return Promise.allSettled([this.loadEpochInfo(), this.connection.getBalance(this.publicKey), (0, _crossFetch.default)(this.evmAPI, {
                  method: 'POST',
                  headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json'
                  },
                  body: "{\"jsonrpc\":\"2.0\",\"id\":".concat(Date.now(), ",\"method\":\"eth_getBalance\",\"params\":[\"").concat(this.evmAddress, "\",\"latest\"]}")
                }), (0, _crossFetch.default)("".concat(this.validatorsBackend, "/v1/validators")), this.fetchAccountsFromBackend ? (0, _crossFetch.default)("".concat(this.validatorsBackend, "/v1/staking-accounts")) : this.connection.getParsedProgramAccounts(_web.StakeProgram.programId, {
                  filters: [filter],
                  commitment: 'processed'
                })]);

              case 4:
                _result = _context9.sent;
                epochInfo = _result[0].status === 'fulfilled' ? _result[0].value : null;
                balanceRes = _result[1].status === 'fulfilled' ? _result[1].value : [];
                balanceEvmRes = _result[2].status === 'fulfilled' ? _result[2].value : [];
                validatorsFromBackendResult = _result[3].status === 'fulfilled' ? _result[3].value : _result[3].reason;
                nativeAccountsFromBackendResult = _result[4].status === 'fulfilled' ? _result[4].value : null;
                validatorsFromBackend = [];
                this.getValidatorsError = null;

                if (!(validatorsFromBackendResult && validatorsFromBackendResult.error)) {
                  _context9.next = 17;
                  break;
                }

                this.getValidatorsError = validatorsFromBackendResult.error;
                this.isRefreshing = false;
                _context9.next = 30;
                break;

              case 17:
                if (!(validatorsFromBackendResult && validatorsFromBackendResult.message && validatorsFromBackendResult.message === 'Network request failed')) {
                  _context9.next = 22;
                  break;
                }

                this.getValidatorsError = validatorsFromBackendResult.message;
                this.isRefreshing = false;
                _context9.next = 30;
                break;

              case 22:
                if (!(validatorsFromBackendResult && validatorsFromBackendResult.json)) {
                  _context9.next = 28;
                  break;
                }

                _context9.next = 25;
                return validatorsFromBackendResult.json();

              case 25:
                _context9.t0 = _context9.sent;
                _context9.next = 29;
                break;

              case 28:
                _context9.t0 = null;

              case 29:
                validatorsFromBackend = _context9.t0;

              case 30:
                _context9.t1 = Promise;

                if (!balanceEvmRes.json) {
                  _context9.next = 37;
                  break;
                }

                _context9.next = 34;
                return balanceEvmRes.json();

              case 34:
                _context9.t2 = _context9.sent;
                _context9.next = 38;
                break;

              case 37:
                _context9.t2 = null;

              case 38:
                _context9.t3 = _context9.t2;
                _context9.next = 41;
                return this.getAccounts(nativeAccountsFromBackendResult);

              case 41:
                _context9.t4 = _context9.sent;
                _context9.t5 = [_context9.t3, _context9.t4];
                _context9.next = 45;
                return _context9.t1.allSettled.call(_context9.t1, _context9.t5);

              case 45:
                result = _context9.sent;
                balanceEvmJson = result[0] && result[0].status === 'fulfilled' ? result[0].value : null; //const validatorsFromBackend = result[1] && result[1].status === 'fulfilled' ? result[1].value : [];

                nativeAccounts = result[1].status === 'fulfilled' ? result[1].value : [];
                filteredAccounts = nativeAccounts.filter(function (it) {
                  return it.staker === _this6.publicKey58;
                });
                stakingAccounts = (filteredAccounts || []).map(function (account) {
                  return new _stakingAccountModel.StakingAccountModel(account, _this6.connection, _this6.network);
                });
                tmp = validatorsFromBackend && validatorsFromBackend.validators ? validatorsFromBackend.validators : validatorsFromBackend || [];
                validators = (tmp || []).map(function (validator) {
                  return new _validatorModelBacked.ValidatorModelBacked(validator, _this6.connection, _this6.network);
                });
                validatorsMap = Object.create(null);

                for (i = 0; i < validators.length; i++) {
                  validatorsMap[validators[i].address] = validators[i];
                }

                i = 0;

              case 55:
                if (!(i < stakingAccounts.length)) {
                  _context9.next = 65;
                  break;
                }

                account = stakingAccounts[i];
                validator = validatorsMap[account.validatorAddress];

                if (validator) {
                  _context9.next = 61;
                  break;
                }

                if (account.isActivated) {
                  console.warn('Validator for account not found', account.validatorAddress);
                }

                return _context9.abrupt("continue", 62);

              case 61:
                validator.addStakingAccount(account);

              case 62:
                i++;
                _context9.next = 55;
                break;

              case 65:
                _context9.next = 67;
                return this.connection.getMinimumBalanceForRentExemption(200);

              case 67:
                rent = _context9.sent;
                this.endRefresh(balanceRes, balanceEvmJson, rent, validators, stakingAccounts, epochInfo);

              case 69:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function reloadFromBackend() {
        return _reloadFromBackend.apply(this, arguments);
      }

      return reloadFromBackend;
    }()
  }, {
    key: "reload",
    value: function () {
      var _reload = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var _this7 = this;

        var epochInfo, balanceRes, balanceEvmRes, balanceEvmJson;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                this.startRefresh();
                _context11.next = 3;
                return this.loadEpochInfo();

              case 3:
                epochInfo = _context11.sent;
                _context11.next = 6;
                return this.connection.getBalance(this.publicKey);

              case 6:
                balanceRes = _context11.sent;
                _context11.next = 9;
                return (0, _crossFetch.default)(this.evmAPI, {
                  method: 'POST',
                  headers: {
                    Accept: 'application/json',
                    'Content-Type': 'application/json'
                  },
                  body: "{\"jsonrpc\":\"2.0\",\"id\":".concat(Date.now(), ",\"method\":\"eth_getBalance\",\"params\":[\"").concat(this.evmAddress, "\",\"latest\"]}")
                });

              case 9:
                balanceEvmRes = _context11.sent;
                _context11.next = 12;
                return balanceEvmRes.json();

              case 12:
                balanceEvmJson = _context11.sent;
                this.connection.getVoteAccounts().then(function (_ref7) {
                  var current = _ref7.current,
                      delinquent = _ref7.delinquent;
                  var filter = {
                    memcmp: {
                      offset: 0xc,
                      bytes: _this7.publicKey58
                    }
                  };

                  _this7.connection.getParsedProgramAccounts(_web.StakeProgram.programId, {
                    filters: [filter],
                    commitment: 'confirmed'
                  }).then( /*#__PURE__*/function () {
                    var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(nativeAccounts) {
                      var filteredAccounts, stakingAccounts, validators, validatorsMap, i, account, validator;
                      return regeneratorRuntime.wrap(function _callee10$(_context10) {
                        while (1) {
                          switch (_context10.prev = _context10.next) {
                            case 0:
                              filteredAccounts = nativeAccounts.filter(function (account) {
                                return account.staker === _this7.publicKey58;
                              });
                              stakingAccounts = (filteredAccounts || []).map(function (account) {
                                return new _stakingAccountModel.StakingAccountModel(account, _this7.connection, _this7.network);
                              });
                              validators = (current || []).map(function (validator) {
                                return new _validatorModel.ValidatorModel(validator, false, _this7.connection, _this7.network);
                              }).concat((delinquent || []).map(function (validator) {
                                return new _validatorModel.ValidatorModel(validator, true, _this7.connection, _this7.network);
                              }));
                              validatorsMap = Object.create(null);

                              for (i = 0; i < validators.length; i++) {
                                validatorsMap[validators[i].address] = validators[i];
                              }

                              i = 0;

                            case 6:
                              if (!(i < stakingAccounts.length)) {
                                _context10.next = 16;
                                break;
                              }

                              account = stakingAccounts[i];
                              validator = validatorsMap[account.validatorAddress];

                              if (validator) {
                                _context10.next = 12;
                                break;
                              }

                              if (account.isActivated) {
                                console.warn('Validator for account not found', account.validatorAddress);
                              }

                              return _context10.abrupt("continue", 13);

                            case 12:
                              validator.addStakingAccount(account);

                            case 13:
                              i++;
                              _context10.next = 6;
                              break;

                            case 16:
                              _this7.connection.getMinimumBalanceForRentExemption(200).then(function (rent) {
                                _this7.endRefresh(balanceRes, balanceEvmJson, rent, validators, stakingAccounts, epochInfo);
                              });

                            case 17:
                            case "end":
                              return _context10.stop();
                          }
                        }
                      }, _callee10);
                    }));

                    return function (_x2) {
                      return _ref8.apply(this, arguments);
                    };
                  }());
                });

              case 14:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function reload() {
        return _reload.apply(this, arguments);
      }

      return reload;
    }()
  }, {
    key: "getDominance",
    value: function getDominance(validator) {
      if (!this.validators) {
        return null;
      }

      var activeValidators = this.validators.filter(function (v) {
        return v.status === 'active';
      });
      var totalStake = new _bn.default(0);

      for (var i = 0; i < activeValidators.length; i++) {
        totalStake = totalStake.add(activeValidators[i].activeStake);
      }

      var part = validator.activeStake.mul(new _bn.default(1000)).div(totalStake).toNumber() / 1000;
      return part - 1 / activeValidators.length;
    }
  }, {
    key: "getQuality",
    value: function getQuality(validator) {
      if (!this.validators) {
        return null;
      }

      var activeValidators = this.validators.filter(function (v) {
        return v.status === 'active';
      });
      var sumBlocks = 0;

      for (var i = 0; i < activeValidators.length; i++) {
        sumBlocks = +activeValidators[i].lastBlock;
      }

      return validator.lastBlock - sumBlocks;
    }
  }, {
    key: "getBalance",
    value: function getBalance() {
      if (!this.vlxEvmBalance || !this.vlxNativeBalance) {
        return null;
      }

      return this.vlxEvmBalance.add(this.vlxNativeBalance);
    }
  }, {
    key: "getAnnualRate",
    value: function getAnnualRate(validator) {
      return validator.apr ? (validator.apr * 100).toFixed(2) : 0;
    }
  }, {
    key: "getNextSeed",
    value: function () {
      var _getNextSeed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var _this8 = this;

        var fromPubkey, addressesHs, _i, i, stakePublilcKey, toBase58;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                fromPubkey = this.publicKey;
                addressesHs = Object.create(null);
                _context12.next = 4;
                return (0, _mobx.when)(function () {
                  return !!_this8.accounts;
                });

              case 4:
                for (_i = 0; _i < this.accounts.length; _i++) {
                  addressesHs[this.accounts[_i].address] = true;
                }

                i = 0;

              case 6:
                if (!true) {
                  _context12.next = 16;
                  break;
                }

                _context12.next = 9;
                return _web.PublicKey.createWithSeed(fromPubkey, i.toString(), _web.StakeProgram.programId);

              case 9:
                stakePublilcKey = _context12.sent;
                toBase58 = stakePublilcKey.toBase58();

                if (!(!addressesHs[toBase58] && !this.seedUsed[i])) {
                  _context12.next = 13;
                  break;
                }

                return _context12.abrupt("break", 16);

              case 13:
                i++;
                _context12.next = 6;
                break;

              case 16:
                this.seedUsed[i] = true;
                return _context12.abrupt("return", i.toString());

              case 18:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getNextSeed() {
        return _getNextSeed.apply(this, arguments);
      }

      return getNextSeed;
    }()
  }, {
    key: "sendTransaction",
    value: function () {
      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(transaction) {
        var feePayer, _yield$this$connectio, blockhash, payAccount, result;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.prev = 0;
                feePayer = this.publicKey;
                _context13.next = 4;
                return this.connection.getRecentBlockhash();

              case 4:
                _yield$this$connectio = _context13.sent;
                blockhash = _yield$this$connectio.blockhash;
                transaction.recentBlockhash = blockhash;
                transaction.feePayer = feePayer;
                _context13.next = 13;
                break;

              case 10:
                _context13.prev = 10;
                _context13.t0 = _context13["catch"](0);
                return _context13.abrupt("return", {
                  error: 'cunstruct_transaction_error',
                  description: _context13.t0.message
                });

              case 13:
                payAccount = new _web.Account(this.secretKey);
                _context13.next = 16;
                return this.connection.sendTransaction(transaction, [payAccount]);

              case 16:
                result = _context13.sent;
                return _context13.abrupt("return", result);

              case 18:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this, [[0, 10]]);
      }));

      function sendTransaction(_x3) {
        return _sendTransaction.apply(this, arguments);
      }

      return sendTransaction;
    }()
  }, {
    key: "waitTransactionMined",
    value: function waitTransactionMined(txHash, interval, resolve, reject) {
      var _this9 = this;

      var self = this;

      var transactionReceiptAsync = function transactionReceiptAsync() {
        _this9.web3.eth.getTransactionReceipt(txHash, function (error, receipt) {
          if (error) {
            reject(error);
          } else if (receipt == null) {
            setTimeout(function () {
              return transactionReceiptAsync();
            }, interval ? interval : 500);
          } else {
            resolve(receipt);
          }
        });
      };

      transactionReceiptAsync();
    }
  }, {
    key: "swapEvmToNative",
    value: function () {
      var _swapEvmToNative = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(swapAmount) {
        var _this10 = this;

        var evmToNativeBridgeContract, nativeHexAddress, data, privateKey, nonce, chainId, customCommon, rawTx, tx, serializedTx;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                evmToNativeBridgeContract = this.web3.eth.contract(_EvmToNativeBridge.default.abi).at('0x56454c41532d434841494e000000000053574150');
                nativeHexAddress = "0x" + _bs.default.decode(this.publicKey.toString()).toString('hex');
                data = evmToNativeBridgeContract.transferToNative.getData(nativeHexAddress);
                privateKey = _buffer.Buffer.from(this.evmPrivateKey.substr(2), 'hex');
                _context14.next = 6;
                return new Promise(function (resolve, reject) {
                  _this10.web3.eth.getTransactionCount(_this10.evmAddress, 'pending', function (err, value) {
                    if (err) return reject(err);
                    resolve(value);
                  });
                });

              case 6:
                nonce = _context14.sent;
                chainId = this.network === 'mainnet' ? 106 : 111;
                customCommon = _ethereumjsCommon.default.forCustomChain('mainnet', {
                  name: 'velas',
                  networkId: chainId,
                  chainId: chainId
                }, 'istanbul');
                rawTx = {
                  nonce: nonce,
                  gasPrice: '0x' + 3000000000 .toString(16),
                  gasLimit: '0x' + 210000 .toString(16),
                  to: '0x56454c41532d434841494e000000000053574150',
                  value: '0x' + swapAmount.mul(new _bn.default(1e9)).toString(16),
                  data: data
                };
                tx = new ethereum.Transaction(rawTx, {
                  common: customCommon
                });
                _context14.prev = 11;
                tx.sign(privateKey);
                _context14.next = 18;
                break;

              case 15:
                _context14.prev = 15;
                _context14.t0 = _context14["catch"](11);
                return _context14.abrupt("return", Promise.reject(_context14.t0));

              case 18:
                serializedTx = tx.serialize();
                _context14.next = 21;
                return new Promise(function (resolve, reject) {
                  _this10.web3.eth.sendRawTransaction('0x' + serializedTx.toString('hex'), function (err, transactionHash) {
                    if (err) {
                      return reject(err);
                    }

                    _this10.waitTransactionMined(transactionHash, 1000, resolve, reject);
                  });
                });

              case 21:
                return _context14.abrupt("return", _context14.sent);

              case 22:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this, [[11, 15]]);
      }));

      function swapEvmToNative(_x4) {
        return _swapEvmToNative.apply(this, arguments);
      }

      return swapEvmToNative;
    }()
  }, {
    key: "stake",
    value: function () {
      var _stake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(address, amount_sol) {
        var transaction, swapAmount, rent, fromPubkey, authorized, lamportsBN, seed, votePubkey, stakePubkey, lockup, config, result;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                transaction = new _web.Transaction();
                swapAmount = this.getSwapAmountByStakeAmount(amount_sol);
                rent = this.rent;
                fromPubkey = this.publicKey;
                authorized = new _web.Authorized(fromPubkey, fromPubkey);
                lamportsBN = new _bn.default(amount_sol).add(rent);
                _context15.next = 8;
                return this.getNextSeed();

              case 8:
                seed = _context15.sent;
                votePubkey = new _web.PublicKey(address);
                _context15.next = 12;
                return _web.PublicKey.createWithSeed(fromPubkey, seed, _web.StakeProgram.programId);

              case 12:
                stakePubkey = _context15.sent;
                lockup = new _web.Lockup(0, 0, fromPubkey);
                config = {
                  authorized: authorized,
                  basePubkey: fromPubkey,
                  fromPubkey: fromPubkey,
                  lamports: lamportsBN.toString(),
                  lockup: lockup,
                  seed: seed,
                  stakePubkey: stakePubkey
                };

                if (swapAmount.isZero()) {
                  _context15.next = 20;
                  break;
                }

                _context15.next = 18;
                return this.swapEvmToNative(swapAmount);

              case 18:
                _context15.next = 20;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, 2000);
                });

              case 20:
                transaction.add(_web.StakeProgram.createAccountWithSeed(config));
                transaction.add(_web.StakeProgram.delegate({
                  authorizedPubkey: fromPubkey,
                  stakePubkey: stakePubkey,
                  votePubkey: votePubkey
                }));
                _context15.prev = 22;
                _context15.next = 25;
                return this.sendTransaction(transaction);

              case 25:
                result = _context15.sent;

                if (!result.error) {
                  _context15.next = 28;
                  break;
                }

                return _context15.abrupt("return", result);

              case 28:
                _context15.next = 30;
                return this.reloadWithRetry();

              case 30:
                return _context15.abrupt("return", result);

              case 33:
                _context15.prev = 33;
                _context15.t0 = _context15["catch"](22);
                return _context15.abrupt("return", {
                  error: _context15.t0
                });

              case 36:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this, [[22, 33]]);
      }));

      function stake(_x5, _x6) {
        return _stake.apply(this, arguments);
      }

      return stake;
    }()
  }, {
    key: "getSwapAmountByStakeAmount",
    value: function getSwapAmountByStakeAmount(amountStr) {
      var amount = typeof amountStr === 'string' ? new _bn.default((amountStr * 1e9).toString(), 10) : amountStr;

      if (!this.vlxNativeBalance) {
        return null;
      }

      if (this.vlxNativeBalance.gte(amount.add(PRESERVE_BALANCE))) {
        return new _bn.default(0);
      }

      if (!this.vlxEvmBalance) {
        return null;
      }

      if (this.vlxNativeBalance.add(this.vlxEvmBalance).lt(amount)) {
        return null;
      }

      if (this.vlxNativeBalance.add(this.vlxEvmBalance).lte(amount.add(PRESERVE_BALANCE))) {
        return this.vlxEvmBalance;
      }

      return amount.add(PRESERVE_BALANCE).sub(this.vlxNativeBalance);
    }
  }, {
    key: "splitStakeAccountTransaction",
    value: function () {
      var _splitStakeAccountTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(stakeAccount, lamports) {
        var transaction, authorizedPubkey, stakePubkey, rent, seed, splitStakePubkey, params;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                if (typeof lamports === 'string') {
                  lamports = new _bn.default(lamports, 10);
                }

                transaction = null;
                authorizedPubkey = this.publicKey;
                stakePubkey = new _web.PublicKey(stakeAccount.address);
                rent = this.rent;
                _context16.next = 7;
                return this.getNextSeed();

              case 7:
                seed = _context16.sent;
                _context16.next = 10;
                return _web.PublicKey.createWithSeed(authorizedPubkey, seed, _web.StakeProgram.programId);

              case 10:
                splitStakePubkey = _context16.sent;
                params = {
                  stakePubkey: stakePubkey,
                  authorizedPubkey: authorizedPubkey,
                  splitStakePubkey: splitStakePubkey,
                  lamports: lamports.add(rent),
                  seed: seed,
                  basePubkey: authorizedPubkey
                };
                return _context16.abrupt("return", _web.StakeProgram.splitWithSeed(params));

              case 13:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function splitStakeAccountTransaction(_x7, _x8) {
        return _splitStakeAccountTransaction.apply(this, arguments);
      }

      return splitStakeAccountTransaction;
    }()
  }, {
    key: "undelegateTransaction",
    value: function () {
      var _undelegateTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(stakePubkey) {
        var transaction, authorizedPubkey;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                transaction = new _web.Transaction();
                authorizedPubkey = this.publicKey;
                transaction.add(_web.StakeProgram.deactivate({
                  authorizedPubkey: authorizedPubkey,
                  stakePubkey: stakePubkey
                }));
                return _context17.abrupt("return", transaction);

              case 4:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function undelegateTransaction(_x9) {
        return _undelegateTransaction.apply(this, arguments);
      }

      return undelegateTransaction;
    }()
  }, {
    key: "requestWithdraw",
    value: function () {
      var _requestWithdraw = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(address, amount) {
        var transaction, validator, sortedAccounts, totalStake, i, account, res;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                if (this.validators) {
                  _context18.next = 2;
                  break;
                }

                throw new Error('Not loaded');

              case 2:
                transaction = new _web.Transaction();
                validator = this.validators.find(function (v) {
                  return v.address === address;
                });

                if (validator) {
                  _context18.next = 6;
                  break;
                }

                throw new Error('Not found');

              case 6:
                sortedAccounts = validator.stakingAccounts.filter(function (a) {
                  return a.state === 'active' || a.state === 'activating';
                }).filter(function (a) {
                  return !a.unixTimestamp || new _bn.default(a.unixTimestamp).lt(new _bn.default(Date.now() / 1000));
                }).sort(function (a, b) {
                  return b.myStake.cmp(a.myStake);
                });
                totalStake = new _bn.default(0);

                if (typeof amount === 'string') {
                  amount = new _bn.default(parseFloat(amount) * 1e9 + '', 10);
                }

                for (i = 0; i < sortedAccounts.length; i++) {
                  totalStake = totalStake.add(sortedAccounts[i].myStake);
                }

                if (totalStake.sub(new _bn.default(10000000)).lt(amount)) {
                  amount = totalStake;
                }

              case 11:
                if (!(!amount.isZero() && !amount.isNeg())) {
                  _context18.next = 35;
                  break;
                }

                account = sortedAccounts.pop();

                if (!amount.gte(account.myStake)) {
                  _context18.next = 22;
                  break;
                }

                _context18.t0 = transaction;
                _context18.next = 17;
                return this.undelegateTransaction(account.publicKey);

              case 17:
                _context18.t1 = _context18.sent;

                _context18.t0.add.call(_context18.t0, _context18.t1);

                amount = amount.sub(account.myStake);
                _context18.next = 33;
                break;

              case 22:
                _context18.t2 = transaction;
                _context18.next = 25;
                return this.splitStakeAccountTransaction(account, account.myStake.sub(amount));

              case 25:
                _context18.t3 = _context18.sent;

                _context18.t2.add.call(_context18.t2, _context18.t3);

                _context18.t4 = transaction;
                _context18.next = 30;
                return this.undelegateTransaction(account.publicKey);

              case 30:
                _context18.t5 = _context18.sent;

                _context18.t4.add.call(_context18.t4, _context18.t5);

                return _context18.abrupt("break", 35);

              case 33:
                _context18.next = 11;
                break;

              case 35:
                _context18.next = 37;
                return this.sendTransaction(transaction);

              case 37:
                res = _context18.sent;

                if (!res.error) {
                  _context18.next = 40;
                  break;
                }

                return _context18.abrupt("return", res);

              case 40:
                _context18.next = 42;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, 2000);
                });

              case 42:
                _context18.next = 44;
                return this.reloadWithRetry();

              case 44:
                return _context18.abrupt("return", res);

              case 45:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function requestWithdraw(_x10, _x11) {
        return _requestWithdraw.apply(this, arguments);
      }

      return requestWithdraw;
    }()
  }, {
    key: "withdrawRequested",
    value: function () {
      var _withdrawRequested = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(address) {
        var _this11 = this;

        var transaction, authorizedPubkey, i, account, _yield$this$connectio2, inactive, state, res;

        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                transaction = new _web.Transaction();
                authorizedPubkey = this.publicKey;
                _context19.next = 4;
                return (0, _mobx.when)(function () {
                  return !!_this11.accounts;
                });

              case 4:
                i = 0;

              case 5:
                if (!(i < this.accounts.length)) {
                  _context19.next = 28;
                  break;
                }

                account = this.accounts[i];

                if (!(account.validatorAddress !== address)) {
                  _context19.next = 9;
                  break;
                }

                return _context19.abrupt("continue", 25);

              case 9:
                if (!(account.unixTimestamp > Date.now() / 1000)) {
                  _context19.next = 11;
                  break;
                }

                return _context19.abrupt("continue", 25);

              case 11:
                _context19.prev = 11;
                _context19.next = 14;
                return this.connection.getStakeActivation(new _web.PublicKey(account.publicKey));

              case 14:
                _yield$this$connectio2 = _context19.sent;
                inactive = _yield$this$connectio2.inactive;
                state = _yield$this$connectio2.state;

                if (!(!inactive || state !== 'inactive' && state !== 'deactivating')) {
                  _context19.next = 19;
                  break;
                }

                return _context19.abrupt("continue", 25);

              case 19:
                transaction.add(_web.StakeProgram.withdraw({
                  authorizedPubkey: authorizedPubkey,
                  stakePubkey: account.publicKey,
                  lamports: state === 'inactive' ? parseFloat(account.myStake.toString(10)) : inactive + this.rent.toNumber(),
                  toPubkey: authorizedPubkey
                }));
                _context19.next = 25;
                break;

              case 22:
                _context19.prev = 22;
                _context19.t0 = _context19["catch"](11);
                console.warn(_context19.t0);

              case 25:
                i++;
                _context19.next = 5;
                break;

              case 28:
                _context19.next = 30;
                return this.sendTransaction(transaction);

              case 30:
                res = _context19.sent;

                if (!res.error) {
                  _context19.next = 33;
                  break;
                }

                return _context19.abrupt("return", res);

              case 33:
                _context19.next = 35;
                return new Promise(function (resolve) {
                  return setTimeout(resolve, 2000);
                });

              case 35:
                _context19.next = 37;
                return this.reloadWithRetry();

              case 37:
                return _context19.abrupt("return", res);

              case 38:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this, [[11, 22]]);
      }));

      function withdrawRequested(_x12) {
        return _withdrawRequested.apply(this, arguments);
      }

      return withdrawRequested;
    }()
  }, {
    key: "sort",
    get: function get() {
      return this._currentSort || localStorage.sort;
    },
    set: function set(value) {
      localStorage.sort = value;
      this._currentSort = value;
    }
  }]);

  return StakingStore;
}();

exports.StakingStore = StakingStore;